.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FPX3 1"
.TH FPX3 1 "2006-02-03" "perl v5.8.5" "User Contributed Perl Documentation"
.SH "Fpx3 \- Fortran Preprocessor with embedded Perl"
.IX Header "Fpx3 - Fortran Preprocessor with embedded Perl"
The purpose of fpx3 is to simplify Fortran source code development with
an integrated set of macros, directives and embedded Perl/Fortran.
Most common tasks can be done without Perl background using the documented
examples. For sophisticated source code transformations Perls broad functionality
can be used. Embedded Fortran can be used for general data initialization.
There is support for Fortran context sensitive macros and local name spaces.
Structural and dependency information for subsequent tools can be generated.
.PP
Fpx3 is probably most useful for large projects with nontrivial hardware and
software dependencies.
It is written in pure Perl and should run on many platforms (tested
on \s-1AIX\s0, Linux, Tru64 \s-1UNIX\s0, Windows \s-1NT\s0).
.PP
The latest version should be available at http://www.gwdg.de/~jbehren/fpx3 .
.SH "Usage:"
.IX Header "Usage:"
fpx3 [\fB\-d\fR] [\fB\-D\fR\fIname\fR[=\fIvalue\fR]] [\fB\-free\fR | \fB\-fixed\fR] [\fB\-[no]dh\fR]
        [\fB\-[no]fo\fR] [\fB\-[no]sh\fR] [\fB\-h\fR] [\fB\-i\fR \fIinitfile\fR] [\fB\-I\fR\fIpath\fR]
        [\fB\-lc\fR] [\fB\-o\fR \fIofile\fR] [\fB\-v\fR] [\fIfile list\fR]
.SH "Options:"
.IX Header "Options:"
.IP "\-d" 4
.IX Item "-d"
Print debug information on stderr.
.IP "\-D\fIname\fR[=\fIvalue\fR]" 4
.IX Item "-Dname[=value]"
Defines $\fIname\fR with \fIvalue\fR if specified, else with 1.
.IP "\-free | \-fixed" 4
.IX Item "-free | -fixed"
Assumes source code is in free (default) or fixed form.
.IP "\-[no]dh or \-[!]gd" 4
.IX Item "-[no]dh or -[!]gd"
Generate dependency header (default).
.IP "\-[no]fo or \-[!]gf" 4
.IX Item "-[no]fo or -[!]gf"
Generate Fortran output (default).
.IP "\-no[sh] or \-[!]gs" 4
.IX Item "-no[sh] or -[!]gs"
Generate structure header.
.IP "\-lc" 4
.IX Item "-lc"
Insert cpp-like line control information for the Fortran compiler,
the style depends on the the value of \f(CW$FC\fR.
.IP "\-i \fIinitfile\fR" 4
.IX Item "-i initfile"
Read the initialization file \fIinitfile\fR and interpret it as Perl code.
Default is the file \fB.fpx3\fR
in the current directory, if present. Otherwise the file \fB~/.fpx3\fR is tried.
An example initialization file is distributed with this program.
.IP "\-I \fIpath\fR" 4
.IX Item "-I path"
Use \fIpath\fR when searching for include files via \f(CW$include\fR.
It is interpreted as sequence of colon (unix) or semicolon
(windows) separated directories.
Can be accessed as \f(CW$include_path\fR.
.IP "\-o \fIofile\fR" 4
.IX Item "-o ofile"
Write output to the file \fIofile\fR instead of stdout.
.IP "\-v" 4
.IX Item "-v"
Show version and exit.
.IP "\fIfile list\fR" 4
.IX Item "file list"
The special filename '\-' means reading from stdin. Stdin is also
used when the file list is empty.
.SH "Description:"
.IX Header "Description:"
All fpx3 macros start with the \fB$\fR character. This gives a non-ambiguous name space
and makes reading Fortran source code with embedded macros easy.
Macros can hold multi line constants,
Perl subroutines or fpx3 subroutines. They are not expanded inside
Fortran comments or strings. Evaluation of an undefined macro causes an error.
The result of a macro expansion is not expanded again but treated as Fortran code.
Standard macros of the form \f(CW$endfoo\fR can be written with spaces between
\&\f(CW$end\fR and \f(CW\*(C`foo\*(C'\fR.
.PP
This document is written with the following convention:
.PP
\&\s-1EOL\s0 := end of line
.PP
\&\fIname\fR := alphanumeric string
.PP
\&\fIperl_exp\fR := any Perl expression
.PP
\&\fIperl_line\fR := single line Perl expression, excluding \s-1EOL\s0
.PP
\&\fItext\fR := one or more lines
.PP
\&\fIline\fR := rest of line, excluding \s-1EOL\s0
.PP
Macros can be accessed as $\fIname\fR or ${\fIname\fR}, for simplicity the second
form is not mentioned explicitly in the following definitions.
.Sh "Directives and Standard Macros"
.IX Subsection "Directives and Standard Macros"
.ie n .IP "$define($\fIname\fR,\fItext\fR [[,$\fIname\fR,\fItext\fR]...])  |  $define\fR $\fIname\fR \fIline \s-1EOL\s0" 4
.el .IP "$define($\fIname\fR,\fItext\fR [[,$\fIname\fR,\fItext\fR]...])  |  \f(CW$define\fR $\fIname\fR \fIline\fR \s-1EOL\s0" 4
.IX Item "$define($name,text [[,$name,text]...])  |  $define $name line EOL"
Expands the second argument and assigns it to $\fIname\fR. E.g.:
.Sp
.Vb 2
\&   $define $x 1
\&   $define $y $x$x
.Ve
.Sp
This assigns 1 to \f(CW$x\fR and 11 to \f(CW$y\fR.
.IP "$undefine $\fIname\fR" 4
.IX Item "$undefine $name"
Removes the definition of $\fIname\fR in the current scope.
See \f(CW$block\fR and \f(CW$sub\fR for local scopes.
.ie n .IP "$eval \fIperl_exp\fR $endeval\fR  |  \f(CW$eva\fRl(\fIperl_exp\fR)  |  \f(CW$eval:\fR \fIperl_line \s-1EOL\s0" 4
.el .IP "$eval \fIperl_exp\fR \f(CW$endeval\fR  |  \f(CW$eva\fRl(\fIperl_exp\fR)  |  \f(CW$eval:\fR \fIperl_line\fR \s-1EOL\s0" 4
.IX Item "$eval perl_exp $endeval  |  $eval(perl_exp)  |  $eval: perl_line EOL"
Evaluates the Perl expression in the user name space.
Use the less fragile long form if fpx3 complains about unbalanced brackets.
Example:
.Sp
.Vb 2
\&   $define $pi 3.1415926535897932
\&   $eval:sqrt(2)*sin($pi/4)
.Ve
.Sp
expands to 1.
.Sp
Embedded Perl is fast since it is evaluated inside the already running
interpreter without \s-1IO\s0 overhead.
.ie n .IP "$perl \fIperl_exp\fR $endperl\fR  |  \f(CW$per\fRl(\fIperl_exp\fR)   | \f(CW$perl:\fR \fIperl_line \s-1EOL\s0" 4
.el .IP "$perl \fIperl_exp\fR \f(CW$endperl\fR  |  \f(CW$per\fRl(\fIperl_exp\fR)   | \f(CW$perl:\fR \fIperl_line\fR \s-1EOL\s0" 4
.IX Item "$perl perl_exp $endperl  |  $perl(perl_exp)   | $perl: perl_line EOL"
Like \f(CW$eval\fR but without result unless a return statement is used. E.g.:
.Sp
.Vb 1
\&   $perl: $x=1; $y=2
.Ve
.Sp
is identical to
.Sp
.Vb 1
\&   $eval: $x=1; $y=2; return ""
.Ve
.Sp
and does the same as
.Sp
.Vb 2
\&   $define $x 1
\&   $define $y 2
.Ve
.Sp
And
.Sp
.Vb 1
\&   $perl: return "$x$y"
.Ve
.Sp
is identical to
.Sp
.Vb 1
\&   $eval: "$x$y"
.Ve
.Sp
and does the same as
.Sp
.Vb 1
\&   $x$y
.Ve
.ie n .IP "$if (\fIperl_exp\fR) \fItext\fR [[$elsif (\fIperl_exp\fR) \fItext\fR]...] [$else \fItext\fR] $endif" 4
.el .IP "$if (\fIperl_exp\fR) \fItext\fR [[$elsif (\fIperl_exp\fR) \fItext\fR]...] [$else \fItext\fR] \f(CW$endif\fR" 4
.IX Item "$if (perl_exp) text [[$elsif (perl_exp) text]...] [$else text] $endif"
Selects and evaluates the appropriate branch.
Enclosing brackets (...) are not required if \s-1EOL\s0
close is meant. Example:
.Sp
.Vb 5
\&   $if $platform eq "IBM.RS6000"
\&      $define $LOC  LOC
\&   $else
\&      $define $LOC %LOC
\&   $endif
.Ve
.ie n .IP "$quote \fItext\fR $endquote" 4
.el .IP "$quote \fItext\fR \f(CW$endquote\fR" 4
.IX Item "$quote text $endquote"
Evaluates to the quoted (raw) \fItext\fR.
.IP "$include \fIfilenames\fR" 4
.IX Item "$include filenames"
Reads the files and evaluates them. Updates the dependency list.
.IP "$local" 4
.IX Item "$local"
Like \f(CW$define\fR, but the scope is local to the \f(CW$sub\fR, \f(CW$block\fR or \f(CW$fprog\fR region.
.ie n .IP "$define $\fIname\fR $sub\fR \fItext\fR \f(CW$endsub" 4
.el .IP "$define $\fIname\fR \f(CW$sub\fR \fItext\fR \f(CW$endsub\fR" 4
.IX Item "$define $name $sub text $endsub"
Defines a macro that can be called with arguments. The evaluation takes
place when $\fIname\fR is used. Arguments are available as \f(CW$0\fR,$1,$2,...
with \f(CW$0\fR set to the macro name. $* gives the comma separated argument list
and $# evaluates to the highest argument index. \f(CW$shift\fR returns \f(CW$0\fR and
shifts the other arguments one index down.
E.g.:
.Sp
.Vb 8
\& $define $pot32 $sub
\&   $local $name $0$1
\&   $local $type $1
\&   $type function $name(a)
\&     $type,intent(in)::a
\&     $name=sqrt(a)**3
\&   end function $name
\& $endsub
.Ve
.Sp
$pot32(real) evaluates to
.Sp
.Vb 4
\&   real function pot32real(a)
\&     real,intent(in)::a
\&     pot32real=sqrt(a)**3
\&   end function pot32real
.Ve
.ie n .IP "$block \fItext\fR $endblock" 4
.el .IP "$block \fItext\fR \f(CW$endblock\fR" 4
.IX Item "$block text $endblock"
Evaluates interior text. \f(CW$local\fR is supported. Example:
.Sp
.Vb 7
\&   $define $const $block
\&      $local $p DOUBLE PRECISION
\&      $local $e .D0
\&      $p::ZERO,ONE,TWO,THREE,FOUR,FIVE
\&      PARAMETER (ZERO=0$e,ONE=1$e,TWO=2$e,THREE=3$e,FOUR=4$e,
\&     *    FIVE=5$e)
\&   $endblock
.Ve
.Sp
$const evaluates to
.Sp
.Vb 3
\&      DOUBLE PRECISION::ZERO,ONE,TWO,THREE,FOUR,FIVE
\&      PARAMETER (ZERO=0.D0,ONE=1.D0,TWO=2.D0,THREE=3.D0,FOUR=4.D0,
\&     *    FIVE=5.D0)
.Ve
.Sp
Blocks can be nested:
.Sp
.Vb 5
\&   $block $local $T tab%tree
\&      $block $local $N $T%node
\&         rpos=$N($N(this_node)%r)%tab_pos
\&      $endblock
\&   $endblock
.Ve
.Sp
expands to
.Sp
.Vb 1
\&         rpos=tab%tree%node(tab%tree%node(this_node)%r)%tab_pos
.Ve
.IP "$str(\fItext\fR)" 4
.IX Item "$str(text)"
Generates a Fortran string with the translation of \fItext\fR.
A shorter syntax for this is $"\fItext\fR".
.ie n .IP "$fprog \fItext\fR $endfprog" 4
.el .IP "$fprog \fItext\fR \f(CW$endfprog\fR" 4
.IX Item "$fprog text $endfprog"
The interior text is evaluated and passed to a Fortran compiler. The generated program
is executed and the result is inserted in the output stream. There are several ways to
influence the compilation: 1. with the \f(CW$FC_CMD\fR macro where the terms \s-1INPUT\s0 and \s-1OUTPUT\s0
must be present (they are place-holders that are replaced internally
with temporary filenames), 2. with the \f(CW$FC\fR and \f(CW$FC_ARGS\fR (optional) macros (used as
"\f(CW\*(C`$FC $FC_ARGS \-o OUTPUT INPUT\*(C'\fR"), or 3. with the environment
variables \s-1FC\s0 and \s-1FC_ARGS\s0 instead of macros. If all cases are inapplicable then
fpx3 tries to guess the right compiler invocation for the current operating system.
Example:
.Sp
.Vb 9
\&   $fprog
\&     $local $kind 4
\&     $local $real real($kind)
\&     program test 
\&     $real::x
\&     x=sqrt(2.0_$kind)
\&     print*,$str($real,parameter::x=),x
\&     end program test
\&   $end fprog
.Ve
.Sp
translates to
.Sp
.Vb 1
\&   real(4),parameter::x=   1.414214
.Ve
.Sp
The program/end program statements are generated automatically if not present:
.Sp
.Vb 1
\&   real(8)::y=$fprog print*,sqrt(3.0_8) $end fprog
.Ve
.Sp
translates to
.Sp
.Vb 1
\&   real(8)::y=   1.73205080756888
.Ve
.Sp
On systems with slow \s-1IO\s0 it is recommended to do all the machine dependent Fortran
initializations in one all-inclusive embedded Fortran program (the generated
constants should be global by nature anyway). \f(CW$fprog\fR regions can be nested like
\&\f(CW$block\fR regions.
.ie n .IP "$fval \fItext\fR $endfval\fR  |  \f(CW$fva\fRl(\fItext\fR)  |  \f(CW$fval:\fR \fIline \s-1EOL\s0" 4
.el .IP "$fval \fItext\fR \f(CW$endfval\fR  |  \f(CW$fva\fRl(\fItext\fR)  |  \f(CW$fval:\fR \fIline\fR \s-1EOL\s0" 4
.IX Item "$fval text $endfval  |  $fval(text)  |  $fval: line EOL"
Similar to \f(CW$fprog\fR for a single expression.
.Sp
.Vb 1
\&   real(8)::y=$fprog print*,sqrt(3.0_8) $end fprog
.Ve
.Sp
can be written as
.Sp
.Vb 1
\&   real(8)::y=$fval(sqrt(3.0_8))
.Ve
.ie n .IP "$discard [\fIlabel\fR \s-1EOL\s0] \fItext\fR $undiscard\fR [\fIlabel]" 4
.el .IP "$discard [\fIlabel\fR \s-1EOL\s0] \fItext\fR \f(CW$undiscard\fR [\fIlabel\fR]" 4
.IX Item "$discard [label EOL] text $undiscard [label]"
The interior \fItext\fR is unconditionally discarded. Example:
.Sp
.Vb 3
\&   $discard UNUSED
\&      dead code
\&   $undiscard UNUSED
.Ve
.IP "$eof" 4
.IX Item "$eof"
Behaves like the physical end of the current file if evaluated.
.Sp
.Vb 3
\&   $if (defined $have_xyz_config) $eof $endif
\&   $define $have_xyz_config 1
\&   ! define xyz_config
.Ve
.IP "$newline" 4
.IX Item "$newline"
Simply adds a newline \- helpful for writing macros on one line.
.IP "$file_name" 4
.IX Item "$file_name"
The name of the current input file.
.IP "$line_num" 4
.IX Item "$line_num"
Current input line number.
.IP "$fixed_form" 4
.IX Item "$fixed_form"
If defined, input is treated as fixed Fortran source.
Corresponds to the \-free / \-fixed command flag.
.IP "$max_line_length" 4
.IX Item "$max_line_length"
Maximal Fortran line length. Influences when output lines are broken.
Default is 72 for fixed form and 132 for free form.
.IP "$env(\fItext\fR)" 4
.IX Item "$env(text)"
Evaluates \fItext\fR and returns the respective process environment value (like \f(CW$eva\fRl($ENV{\fItext\fR}) ).
.IP "$context_doc" 4
.IX Item "$context_doc"
Evaluates to a short info about the Fortran context. E.g., in the code
.Sp
.Vb 9
\&   module test_mod
\&     contains
\&     subroutine test_sub
\&       contains
\&       subroutine test_isub
\&         print*,$str(start $context_doc)
\&       end subroutine test_isub
\&     end subroutine test_sub
\&   end module test_mod
.Ve
.Sp
the print statement translates to
.Sp
.Vb 1
\&         print*,'start <test_mod:test_sub:test_isub>'
.Ve
.IP "$this_module" 4
.IX Item "$this_module"
Gives the name of the current module.
.IP "$used_modules" 4
.IX Item "$used_modules"
A comma separated list of used modules.
.ie n .IP "$init_modules | $init_module\fRs(\fItext)" 4
.el .IP "$init_modules | \f(CW$init_module\fRs(\fItext\fR)" 4
.IX Item "$init_modules | $init_modules(text)"
Expands to Fortran calls to init-subroutines for all used modules.
Example:
.Sp
.Vb 8
\&   module test
\&     use subtest1
\&     use subtest2
\&     contains
\&     subroutine init_$this_module(istate)
\&       $init_modules(istate)
\&     end subroutine init_$this_module
\&   end module test
.Ve
.Sp
expands to
.Sp
.Vb 9
\&   module test
\&     use subtest1
\&     use subtest2
\&     contains
\&     subroutine init_test(istate)
\&         call init_subtest1(istate)
\&         call init_subtest2(istate)
\&     end subroutine init_test
\&   end module test
.Ve
.IP "$LHS" 4
.IX Item "$LHS"
The left hand side of the current Fortran assignment statement.
Generates an error outside assignments. E.g.:
.Sp
.Vb 1
\&   this_state(i,j,k)=IBSET($LHS,this_flag)
.Ve
.Sp
translates to
.Sp
.Vb 1
\&   this_state(i,j,k)=IBSET(this_state(i,j,k),this_flag)
.Ve
.ie n .IP "$attribute \fIattribute\fR \s-1EOL\s0 \fItext\fR $endattribute" 4
.el .IP "$attribute \fIattribute\fR \s-1EOL\s0 \fItext\fR \f(CW$endattribute\fR" 4
.IX Item "$attribute attribute EOL text $endattribute"
In \fItext\fR every Fortran relevant term '::' is changed to ',\fIattribute\fR::'.
The current attribute is stored in \f(CW$attribute_value\fR. Attributes can be nested.
Example:
.Sp
.Vb 7
\&   $attribute private,save
\&      integer::ix,iy,iz
\&      real(dp_kind)::rx,ry,rz
\&   $attribute dimension(:),allocatable
\&      real(dp_kind)::vec
\&   $end attribute
\&   $end attribute
.Ve
.Sp
translates to
.Sp
.Vb 3
\&      integer,private,save::ix,iy,iz
\&      real(dp_kind),private,save::rx,ry,rz
\&      real(dp_kind),private,save,dimension(:),allocatable::vec
.Ve
.IP "$warn(\fItext\fR)" 4
.IX Item "$warn(text)"
Generates a warning message stderr.
.IP "$error(\fItext\fR)" 4
.IX Item "$error(text)"
Generates an error message on stderr and exits fpx3.
.ie n .IP "$i[kind]_[function], $r[kind]_[function], $[i|l|r|z]_kind" 4
.el .IP "$i[kind]_[function], \f(CW$r\fR[kind]_[function], $[i|l|r|z]_kind" 4
.IX Item "$i[kind]_[function], $r[kind]_[function], $[i|l|r|z]_kind"
These macros correspond to numeric enquiry functions of Fortran90. They are
determined via a set of test programs that are translated with the current Fortran
compiler command (see \f(CW$fprog\fR). The results are cached and only updated when
the hostname or the compiler invocation changes. The available functions are
\&\fBbit_size, digits, huge, radix, range\fR for integers and
\&\fBdigits, epsilon, huge, maxexponent, minexponent, radix, range, tiny\fR for reals.
Examples:
.Sp
Default kinds of integer,logical,real,complex:
.Sp
.Vb 1
\&   $i_kind, $l_kind, $r_kind, $z_kind
.Ve
.Sp
Check if real(16) is available:
.Sp
.Vb 5
\&   $ifdef $r16_kind
\&      integer,parameter::my_r_kind=16
\&   $else
\&      integer,parameter::my_r_kind=8
\&   $endif
.Ve
.Sp
The bit_size of default integer:
.Sp
.Vb 1
\&   $i_bit_size
.Ve
.ie n .IP "$map($sub \fItext\fR $endsub, arg1,arg2,...)" 4
.el .IP "$map($sub \fItext\fR \f(CW$endsub\fR, arg1,arg2,...)" 4
.IX Item "$map($sub text $endsub, arg1,arg2,...)"
The first argument of map must be an unnamed fpx3\-sub. It is applied to each of the following
arguments. Example:
.Sp
.Vb 1
\&   $map($sub print*,$str($1 =),eat_sum%$1 * tmp $newline $endsub,t,p,xc,coul,con,etot)
.Ve
.Sp
expands to
.Sp
.Vb 6
\&      print*,'t =',eat_sum%t * tmp
\&      print*,'p =',eat_sum%p * tmp
\&      print*,'xc =',eat_sum%xc * tmp
\&      print*,'coul =',eat_sum%coul * tmp
\&      print*,'con =',eat_sum%con * tmp
\&      print*,'etot =',eat_sum%etot * tmp
.Ve
.ie n .IP "$map2($sub \fItext\fR $endsub, arg1,arg2,...)" 4
.el .IP "$map2($sub \fItext\fR \f(CW$endsub\fR, arg1,arg2,...)" 4
.IX Item "$map2($sub text $endsub, arg1,arg2,...)"
Like map \- but here the arguments after the sub are treated as comma separated lists.
All lists are splitted and combined to one big list of arguments. Example:
.Sp
.Vb 5
\&   program test
\&     $define $list1 1,2
\&     $define $list2 3
\&     $map2($sub call my_func($1) $newline $endsub,$list1,$list2)
\&   end program test
.Ve
.Sp
expands to
.Sp
.Vb 5
\&   program test
\&      call my_func(1)
\&      call my_func(2)
\&      call my_func(3)
\&   end program test
.Ve
.Sp
program test
.Sh "End-of-line Conditionals"
.IX Subsection "End-of-line Conditionals"
These are simple shortcuts for already existing conditionals.
The form is $\fIname\fR \fImodifier\fR \s-1EOL\s0. They are
not active inside quote\-, Perl\-, comment\-, or string\-context.
The special meaning only applies to free source form:
.PP
In the following, \s-1SOL\s0 means \fIstart of line\fR.
.IP "$\fIname\fR* \s-1EOL\s0" 4
.IX Item "$name* EOL"
Same as \s-1SOL\s0 \f(CW$if\fR (defined $\fIname\fR) \fIline\fR \s-1EOL\s0 \f(CW$endif\fR. E.g.:
.Sp
.Vb 3
\&   any_statement
\&   call only_for_mpi() $mpi*
\&   any_statement
.Ve
.IP "$\fIname\fR+ \s-1EOL\s0 \fItext\fR $\fIname\fR\- \s-1EOL\s0" 4
.IX Item "$name+ EOL text $name- EOL"
Same as \s-1SOL\s0 \f(CW$if\fR (defined $\fIname\fR) \fIline\fR \s-1EOL\s0 \fItext\fR \f(CW$endif\fR. E.g.:
.Sp
.Vb 5
\&   any_statement
\&   first_mpi_statement $mpi+
\&   second_mpi_statement
\&   last_mpi_statement  $mpi-
\&   any_statement
.Ve
.Sh "Other Shortcuts"
.IX Subsection "Other Shortcuts"
.ie n .IP "$(\fIperl_exp\fR)   :=   $eva\fRl(\fIperl_exp)" 4
.el .IP "$(\fIperl_exp\fR)   :=   \f(CW$eva\fRl(\fIperl_exp\fR)" 4
.IX Item "$(perl_exp)   :=   $eval(perl_exp)"
.PD 0
.IP "$()  can be used as zero wide separator" 4
.IX Item "$()  can be used as zero wide separator"
.ie n .IP "$: \fIperl_line\fR \s-1EOL\s0   :=   $eval:\fR \fIperl_line \s-1EOL\s0" 4
.el .IP "$: \fIperl_line\fR \s-1EOL\s0   :=   \f(CW$eval:\fR \fIperl_line\fR \s-1EOL\s0" 4
.IX Item "$: perl_line EOL   :=   $eval: perl_line EOL"
.ie n .IP "$ifdef \fIperl_line\fR   :=   $if\fR (defined \fIperl_line)" 4
.el .IP "$ifdef \fIperl_line\fR   :=   \f(CW$if\fR (defined \fIperl_line\fR)" 4
.IX Item "$ifdef perl_line   :=   $if (defined perl_line)"
.ie n .IP "$ifndef \fIperl_line\fR   :=   $if\fR (!defined \fIperl_line)" 4
.el .IP "$ifndef \fIperl_line\fR   :=   \f(CW$if\fR (!defined \fIperl_line\fR)" 4
.IX Item "$ifndef perl_line   :=   $if (!defined perl_line)"
.IP "$platform   :=   $($ENV{\s-1PLATFORM\s0} || $^O)" 4
.IX Item "$platform   :=   $($ENV{PLATFORM} || $^O)"
.IP "$hostname   :=   $(`hostname`)" 4
.IX Item "$hostname   :=   $(`hostname`)"
.ie n .IP "$rem \fIline\fR \s-1EOL\s0   :=   $discard\fR \fIline\fR \f(CW$undiscard \s-1EOL\s0" 4
.el .IP "$rem \fIline\fR \s-1EOL\s0   :=   \f(CW$discard\fR \fIline\fR \f(CW$undiscard\fR \s-1EOL\s0" 4
.IX Item "$rem line EOL   :=   $discard line $undiscard EOL"
.ie n .IP "$dnl \fIline\fR \s-1EOL\s0   :=   $discard\fR \fIline\fR \s-1EOL\s0 \f(CW$undiscard" 4
.el .IP "$dnl \fIline\fR \s-1EOL\s0   :=   \f(CW$discard\fR \fIline\fR \s-1EOL\s0 \f(CW$undiscard\fR" 4
.IX Item "$dnl line EOL   :=   $discard line EOL $undiscard"
.PD
.Sh "Macro access within Perl"
.IX Subsection "Macro access within Perl"
You probably don't need to care about what is said in this section unless you
really want to get involved with Perl.
.IP "Constant scalars" 4
.IX Item "Constant scalars"
Constant scalars are directly accessible from Perl. E.g.,
.Sp
.Vb 1
\&   $perl: $five=0b0101; $fpx3="f" . "p" x 3
.Ve
.Sp
assigns the value 5 to \f(CW$five\fR and fppp to \f(CW$fpx3\fR. 
.IP "Simple functional macros" 4
.IX Item "Simple functional macros"
Functional macro definitions in Perl can be done using the supplied \fBmacro\fR subroutine:
.Sp
.Vb 2
\&   $perl: $count=0; macro $counter, sub { $count=$count+1; return $count }
\&   integer:: i$counter,i$counter,i$counter,i$counter
.Ve
.Sp
This ties the anonymous sub to the scalar \f(CW$counter\fR. Every access to
\&\f(CW$counter\fR executes the sub. The result is:
.Sp
.Vb 1
\&   integer:: i1,i2,i3,i4
.Ve
.IP "Functional macros with arguments" 4
.IX Item "Functional macros with arguments"
Macro arguments are not collected automatically. You need to call \fB\f(BIget_args()\fB\fR.
E.g.:
.Sp
.Vb 8
\&   $perl
\&   macro $stop, sub {
\&     my @a=get_args();
\&     err("bad usage of stop macro") if scalar @a > 1;
\&     return "call my_stop(@a)" if @a;
\&     return "call my_stop(\e'$context_doc\e')";
\&   };
\&   $endperl
.Ve
.Sp
Simple functional macros like this take their arguments only from the input stream.
They cannot be used inside a Perl expression. E.g.,
.Sp
.Vb 1
\&   $eval: $stop('message') # leads to a Perl syntax error
.Ve
.IP "General functional macros" 4
.IX Item "General functional macros"
To be more general use the slightly more complicated \fBxmacro\fR:
.Sp
.Vb 8
\&   $perl
\&   xmacro 'stop', sub {
\&     my @a=@_; @a=get_args() unless @a;
\&     err("bad usage of stop macro") if scalar @a > 1;
\&     return "call my_stop(@a)" if @a;
\&     return "call my_stop(\e'$context_doc\e')";
\&   };
\&   $endperl
.Ve
.Sp
Here \f(CW$sto\fRp('message') is equivalent to the Perl call \f(CW$eva\fRl(&$stop(\*(L"'message'\*(R")).
.SH "Examples"
.IX Header "Examples"
This section shows how to solve some common tasks. The
examples should be transferable without Perl background.
.IP "stringwise/numerical comparision" 4
.IX Item "stringwise/numerical comparision"
.Vb 2
\&   $if ($var1 eq $var2) ... $endif
\&   $if ($var1 lt "this text constant") ... $endif
.Ve
.Sp
The stringwise comparision operators are: \fBeq\fR (equal),  \fBne\fR (not equal),
\&\fBlt\fR (less than), \fBgt\fR (greater than), \fBle\fR (less than or equal) and
\&\fBge\fR (greater than or equal). For numerical comparision use:
\&\fB<\fR, \fB>\fR, \fB<=\fR, \fB>=\fR, \fB==\fR, \fB!=\fR.
.IP "string matching" 4
.IX Item "string matching"
.Vb 2
\&   $define $FC mpxlf95
\&   $if ($FC =~ /xlf/) ... $endif
.Ve
.Sp
The logical expression is true if \f(CW$FC\fR contains the string \*(L"xlf\*(R".
.IP "external programs" 4
.IX Item "external programs"
.Vb 1
\&   $: `my_program my_args`
.Ve
.Sp
Use backticks around the program call. Here the output is directly inserted in the output stream.
.IP "integer/floating\-point arithmetic" 4
.IX Item "integer/floating-point arithmetic"
.Vb 1
\&   $: 7/3
.Ve
.Sp
evaluates to 2.33333333333333
.Sp
.Vb 1
\&   $: use integer; 7/3
.Ve
.Sp
evaluates to 2.
.SH "Bugs"
.IX Header "Bugs"
The core of fpx3 has left the experimental state and is stable for some time now.
But newer features may carry new problems. Please send bugs and comments to
jbehren at gwdg dot de (translate at and dot, ignore whitespace).
.SH "See also"
.IX Header "See also"
.Vb 2
\& perl(1) and references therein,
\& cpp(1), m4(1), fweb(1), f90ppr(1), coco(1)
.Ve
.SH "Copying"
.IX Header "Copying"
.Vb 4
\& This documentation is part of the fpx3 program.
\& Copyright (c) 2002-2004, Jörg Behrens. All rights reserved.
\& fpx3 is free software; you can redistribute it
\& and/or modify it under the same terms as Perl itself.
.Ve
